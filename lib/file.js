// Generated by CoffeeScript 1.4.0
var BUF_LENGTH, copy, dir, fs, getFileName, marked, mkdir, moment, path, read, readJSON, write, _buff;

fs = require('fs');

path = require('path');

moment = require('moment');

marked = require('marked');

marked.setOptions({
  gfm: true,
  pedantic: false,
  sanitize: false
});

mkdir = exports.mkdir = function(dest) {
  var parent;
  dest = path.resolve(dest);
  parent = path.dirname(dest);
  if (fs.existsSync(parent)) {
    return fs.mkdirSync(dest);
  } else {
    mkdir(parent);
    return fs.mkdirSync(dest);
  }
};

dir = exports.dir = function(src, notRecursive, onlyDir) {
  var filePaths,
    _this = this;
  if (!fs.existsSync(src)) {
    return [];
  }
  if (!fs.statSync(src).isDirectory()) {
    return [src];
  }
  filePaths = [];
  fs.readdirSync(src).forEach(function(filename, i) {
    filename = path.resolve(src, filename);
    if (fs.statSync(filename).isDirectory()) {
      if (!notRecursive) {
        return filePaths = filePaths.concat(dir(filename, notRecursive, onlyDir));
      } else {
        return filePaths.push(filename);
      }
    } else {
      if (!onlyDir) {
        return filePaths.push(filename);
      }
    }
  });
  return filePaths;
};

read = exports.read = function(src) {
  if (fs.existsSync(src)) {
    return fs.readFileSync(src, 'utf8');
  } else {
    return '';
  }
};

write = exports.write = function(src, content) {
  var parent;
  parent = path.dirname(src);
  if (!fs.existsSync(parent)) {
    mkdir(parent);
  }
  return fs.writeFileSync(src, content, 'utf8');
};

exports.writeIfNotExist = function(src, content) {
  if (!fs.existsSync(src)) {
    write(src, content);
    return true;
  } else {
    return false;
  }
};

/*
	src: '/home/user/a'
	dest: '/home/user/b'
	force: true
*/


BUF_LENGTH = 64 * 1024;

_buff = new Buffer(BUF_LENGTH);

copy = exports.copy = function(src, dest, force) {
  var bytesRead, destExist, fdr, fdw, pos,
    _this = this;
  destExist = fs.existsSync(dest);
  if (!force && destExist) {
    return false;
  }
  if (fs.statSync(src).isDirectory()) {
    if (!destExist) {
      mkdir(dest);
    }
    fs.readdirSync(src).forEach(function(filename, i) {
      return copy(path.resolve(src, filename), path.resolve(dest, filename), force);
    });
  } else {
    /*
    		if force and destExist
    			console.log(dest)
    			fs.unlinkSync(dest) # remove dest file
    		fs.createReadStream(src).pipe(fs.createWriteStream(dest))
    */

    fdr = fs.openSync(src, 'r');
    fdw = fs.openSync(dest, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
      bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
      fs.writeSync(fdw, _buff, 0, bytesRead);
      pos += bytesRead;
    }
    fs.closeSync(fdr);
    fs.closeSync(fdw);
  }
  return true;
};

readJSON = exports.readJSON = function(src) {
  var content;
  content = read(src);
  if (content) {
    return JSON.parse(content);
  } else {
    return '';
  }
};

getFileName = exports.getFileName = function(filePath) {
  return filePath.replace(path.dirname(filePath) + '/', '');
};

exports.pathToTitle = function(filePath) {
  /*
  	fileName = getFileName(filePath).slice(0, -3)
  	fileName = fileName
  		.replace(/([^\\])\-/g, '$1 ')
  		.replace(/\\-/g, '-')
  	fileName.slice(0, 1).toUpperCase() + fileName.slice(1)
  */

  var content;
  content = read(filePath);
  return content.slice(0, content.indexOf('\n'));
};

exports.titleToPath = function(title) {
  var escapedWords, filename, words;
  if (typeof title === 'object') {
    words = title;
  } else {
    words = [title];
  }
  escapedWords = [];
  words.forEach(function(word, i) {
    return escapedWords[i] = word.replace(/\-/g, '\\$1');
  });
  filename = escapedWords.join('-').toLowerCase();
  if (filename.slice(-3) !== '.md') {
    return filename = filename + '.md';
  }
};

exports.pathToUrl = function(filePath, root) {
  return '/' + path.relative(root, filePath);
};

exports.getCTime = function(filePath, format) {
  var stat;
  stat = fs.statSync(filePath);
  format = format || 'YYYY-MM-DD hh:mm:ss';
  return moment(stat.ctime).format(format);
};

exports.getMTime = function(filePath, format) {
  var stat;
  stat = fs.statSync(filePath);
  format = format || 'YYYY-MM-DD hh:mm:ss';
  return moment(stat.mtime).format(format);
};

exports.mdToHtml = function(filePath) {
  if (filePath.slice(-3) === '.md') {
    filePath = filePath.slice(0, -3) + '.html';
  }
  return filePath;
};

exports.isMd = function(filePath) {
  return filePath.slice(-3) === '.md';
};

exports.isHide = function(filePath) {
  return getFileName(filePath)[0] === '.';
};

exports.readMdToHtml = function(filePath) {
  var file;
  return file = marked(read(filePath));
};

exports.sortByCreateTime = function(paths) {
  var _this = this;
  return paths.sort(function(a, b) {
    return _this.getCTime(a) < _this.getCTime(b);
  });
};

exports.exists = function(path) {
  var p, result, _fn, _i, _len;
  if (typeof path === !'string') {
    result = true;
    _fn = function(p) {
      if (!fs.existsSync(p)) {
        return result = false;
      }
    };
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      _fn(p);
    }
    return result;
  } else {
    return fs.existsSync(path);
  }
};
